// $Id$
#include <iostream>
#include <fstream>
#include <sstream>
#include <cassert>
#include <boost/tokenizer.hpp>

#include "nuto/visualize/CellHexahedron.h"
#include "nuto/visualize/CellLine.h"
#include "nuto/visualize/CellPyramid.h"
#include "nuto/visualize/CellQuad.h"
#include "nuto/visualize/CellTetra.h"
#include "nuto/visualize/CellTriangle.h"
#include "nuto/visualize/Point.h"
#include "nuto/visualize/VisualizeException.h"
#include "nuto/visualize/VisualizeUnstructuredGrid.h"

// add point
unsigned int NuTo::VisualizeUnstructuredGrid::AddPoint(const double* rCoordinates)
{
    this->mPoints.push_back(new Point(rCoordinates));
    unsigned int PointId = this->mPoints.size() - 1;
    for (unsigned int PointDataCount = 0; PointDataCount < this->mPointData.size(); PointDataCount++)
    {
        switch (this->mPointData[PointDataCount].GetDataType())
        {
        case NuTo::VisualizeDataType::SCALAR:
            this->mPoints[PointId].AddDataScalar(PointDataCount);
            break;
        case NuTo::VisualizeDataType::VECTOR:
            this->mPoints[PointId].AddDataVector(PointDataCount);
            break;
        case NuTo::VisualizeDataType::TENSOR:
            this->mPoints[PointId].AddDataTensor(PointDataCount);
            break;
        case NuTo::VisualizeDataType::FIELD:
            this->mPoints[PointId].AddDataField(PointDataCount, this->mPointData[PointDataCount].GetNumData());
            break;
        default:
            throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::AddPoint] Unsupported data type.");
        }
    }
    return PointId;
}

// add line cell
unsigned int NuTo::VisualizeUnstructuredGrid::AddLineCell(const unsigned int* rPoints)
{
    this->CheckPoints(2,rPoints);
    this->mCells.push_back(new CellLine(rPoints,this->mCellData));
    return this->mCells.size() - 1;
}

// add triangle cell
unsigned int NuTo::VisualizeUnstructuredGrid::AddTriangleCell(const unsigned int* rPoints)
{
    this->CheckPoints(3,rPoints);
    this->mCells.push_back(new CellTriangle(rPoints,this->mCellData));
    return this->mCells.size() - 1;
}

// add quadrilateral cell
unsigned int NuTo::VisualizeUnstructuredGrid::AddQuadCell(const unsigned int* rPoints)
{
    this->CheckPoints(4,rPoints);
    this->mCells.push_back(new CellQuad(rPoints,this->mCellData));
    return this->mCells.size() - 1;
}

// add tetraeder cell
unsigned int NuTo::VisualizeUnstructuredGrid::AddTetraCell(const unsigned int* rPoints)
{
    this->CheckPoints(4,rPoints);
    this->mCells.push_back(new CellTetra(rPoints,this->mCellData));
    return this->mCells.size() - 1;
}

// add pyramid cell
unsigned int NuTo::VisualizeUnstructuredGrid::AddPyramidCell(const unsigned int* rPoints)
{
    this->CheckPoints(5,rPoints);
    this->mCells.push_back(new CellPyramid(rPoints,this->mCellData));
    return this->mCells.size() - 1;
}

// add hexahedron cell
unsigned int NuTo::VisualizeUnstructuredGrid::AddHexahedronCell(const unsigned int* rPoints)
{
    this->CheckPoints(8,rPoints);
    this->mCells.push_back(new CellHexahedron(rPoints,this->mCellData));
    return this->mCells.size() - 1;
}

// export to Vtk Datafile
void NuTo::VisualizeUnstructuredGrid::ExportVtkDataFile(const std::string& rFilename) const
{
    std::ofstream file(rFilename.c_str());
    if (!file.is_open())
    {
    	throw NuTo::VisualizeException(std::string("[NuTo::VisualizeUnstructuredGrid::ExportVtkDatafile] Error opening file ")+rFilename.c_str());
    }
    // header /////////////////////////////////////////////////////////////////
    file << "# vtk DataFile Version 3.0" << std::endl;
    file << "Data file was generated by NuTo" << std::endl;
    file << "ASCII" << std::endl;
    file << "DATASET UNSTRUCTURED_GRID" << std::endl;
    ///////////////////////////////////////////////////////////////////////////

    // Points /////////////////////////////////////////////////////////////////
    file << "POINTS " << this->mPoints.size() << " double" << std::endl;
    // modify format for point coordinate output
    std::ios_base::fmtflags OriginalFlags = file.flags(); // store original format
    file.setf(std::ios_base::uppercase | std::ios_base::scientific | std::ios_base::showpos);
    // write point coordinates to file
    boost::ptr_vector<Point>::const_iterator PointIter = this->mPoints.begin();
    while (PointIter != this->mPoints.end())
    {
        const double* PointCoordinates = PointIter->GetCoordinates();
        file << PointCoordinates[0] << " " << PointCoordinates[1] << " " << PointCoordinates[2] << " " << std::endl;
        PointIter++;
    }
    // reset original format
    file.flags(OriginalFlags);
    ///////////////////////////////////////////////////////////////////////////

    // Cells //////////////////////////////////////////////////////////////////
    boost::ptr_vector<CellBase>::const_iterator CellIter = this->mCells.begin();
    unsigned int TotalCellSize(0);
    while (CellIter != this->mCells.end())
    {
        TotalCellSize += 1 + CellIter->GetNumPoints();
        CellIter++;
    }
    file << "CELLS " << this->mCells.size() << " " << TotalCellSize << std::endl;
    CellIter = this->mCells.begin();
    while (CellIter != this->mCells.end())
    {
        unsigned int NumPoints = CellIter->GetNumPoints();
        file << NumPoints;
        const unsigned int *Points = CellIter->GetPoints();
        for (unsigned int PointCount = 0; PointCount < NumPoints; PointCount++)
        {
            file << " " << Points[PointCount];
        }
        file << std::endl;
        CellIter++;
    }
    file << "CELL_TYPES " << this->mCells.size() << std::endl;
    CellIter = this->mCells.begin();
    while (CellIter != this->mCells.end())
    {
        file << CellIter->GetVtkCellType() << std::endl;
        CellIter++;
    }
    ///////////////////////////////////////////////////////////////////////////

    // Point data /////////////////////////////////////////////////////////////
    file << std::endl;
    file << "POINT_DATA " << this->mPoints.size() << std::endl;
    for (unsigned int PointDataCount = 0; PointDataCount < this->mPointData.size(); PointDataCount++)
    {
        switch (this->mPointData[PointDataCount].GetDataType())
        {
        case NuTo::VisualizeDataType::SCALAR:
            file << "SCALARS " << this->mPointData[PointDataCount].GetIdent() << " double 1" << std::endl;
            file << "LOOKUP_TABLE default" << std::endl;
            break;
        case NuTo::VisualizeDataType::VECTOR:
            file << "VECTORS " << this->mPointData[PointDataCount].GetIdent() << " double" << std::endl;
            break;
        case NuTo::VisualizeDataType::TENSOR:
            file << "TENSORS " << this->mPointData[PointDataCount].GetIdent() << " double" << std::endl;
            break;
        case NuTo::VisualizeDataType::FIELD:
            file << "FIELD " << this->mPointData[PointDataCount].GetIdent() << " 1" << std::endl;
            file << this->mPointData[PointDataCount].GetIdent() << " " << this->mPointData[PointDataCount].GetNumData() << " " << this->mPoints.size() << " double" << std::endl;
            break;
        default:
            continue;
        }
        boost::ptr_vector<Point>::const_iterator PointIter = this->mPoints.begin();
        while (PointIter != this->mPoints.end())
        {
            const VisualizeDataBase* tmpData = PointIter->GetData(PointDataCount);
            if (tmpData->GetDataType() != this->mPointData[PointDataCount].GetDataType())
            {
                throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::ExportVtkDatafile] mismatch in point data.");
            }
            file << *tmpData << std::endl;
            PointIter++;
        }
    }
    ///////////////////////////////////////////////////////////////////////////

    // Cell data //////////////////////////////////////////////////////////////
    file << std::endl;
    file << "CELL_DATA " << this->mCells.size() << std::endl;
    for (unsigned int CellDataCount = 0; CellDataCount < this->mCellData.size(); CellDataCount++)
    {
        switch (this->mCellData[CellDataCount].GetDataType())
        {
        case NuTo::VisualizeDataType::SCALAR:
            file << "SCALARS " << this->mCellData[CellDataCount].GetIdent() << " double 1" << std::endl;
            file << "LOOKUP_TABLE default" << std::endl;
            break;
        case NuTo::VisualizeDataType::VECTOR:
            file << "VECTORS " << this->mCellData[CellDataCount].GetIdent() << " double" << std::endl;
            break;
        case NuTo::VisualizeDataType::TENSOR:
            file << "TENSORS " << this->mCellData[CellDataCount].GetIdent() << " double" << std::endl;
            break;
        case NuTo::VisualizeDataType::FIELD:
            file << "FIELD " << this->mCellData[CellDataCount].GetIdent() << " 1" << std::endl;
            file << this->mCellData[CellDataCount].GetIdent() << " " << this->mCellData[CellDataCount].GetNumData() << " " << this->mCells.size() << " double" << std::endl;
            break;
        default:
            continue;
        }
        boost::ptr_vector<CellBase>::const_iterator CellIter = this->mCells.begin();
        while (CellIter != this->mCells.end())
        {
            const VisualizeDataBase* tmpData = CellIter->GetData(CellDataCount);
            if (tmpData->GetDataType() != this->mCellData[CellDataCount].GetDataType())
            {
                throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::ExportVtkDatafile] mismatch in cell data.");
            }
            file << *tmpData << std::endl;
            CellIter++;
        }
    }
    ///////////////////////////////////////////////////////////////////////////

    file.close();
}

// export to Vtu Datafile (XML based file format)
void NuTo::VisualizeUnstructuredGrid::ExportVtuDataFile(const std::string& rFilename) const
{
    std::ofstream file(rFilename.c_str());
    if (!file.is_open())
    {
    	throw NuTo::VisualizeException(std::string("[NuTo::VisualizeUnstructuredGrid::ExportVtuDatafile] Error opening file ")+rFilename.c_str());
    }
    // header /////////////////////////////////////////////////////////////////
    file << "<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">" << std::endl;
    file << "  <UnstructuredGrid>" << std::endl;
    file << "    <Piece NumberOfPoints=\"" << this->mPoints.size() << "\" NumberOfCells=\"" << this->mCells.size() << "\">" << std::endl;
    ///////////////////////////////////////////////////////////////////////////


    // point data /////////////////////////////////////////////////////////////////
    file << "      <PointData>"<< std::endl;

    for (unsigned int PointDataCount = 0; PointDataCount < this->mPointData.size(); PointDataCount++)
    {
        file << "        <DataArray type=\"Float32\" Name=\"" << this->mPointData[PointDataCount].GetIdent() << "\" NumberOfComponents=\"" << this->mPointData[PointDataCount].GetNumData() << "\" Format=\"ascii\">" << std::endl;
        boost::ptr_vector<Point>::const_iterator PointIter = this->mPoints.begin();
        while (PointIter != this->mPoints.end())
        {
            const VisualizeDataBase* tmpData = PointIter->GetData(PointDataCount);
            if (tmpData->GetDataType() != this->mPointData[PointDataCount].GetDataType())
            {
                throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::ExportVtkDatafile] mismatch in point data.");
            }
            file <<"          " << *tmpData << std::endl;
            PointIter++;
        }
        file << "        </DataArray>" << std::endl;
    }

    file << "      </PointData>"<< std::endl;

    // cell data /////////////////////////////////////////////////////////////////
    file << "      <CellData>"<< std::endl;

    for (unsigned int CellDataCount = 0; CellDataCount < this->mCellData.size(); CellDataCount++)
    {
        file << "        <DataArray type=\"Float32\" Name=\"" << this->mCellData[CellDataCount].GetIdent() << "\" NumberOfComponents=\"" << this->mCellData[CellDataCount].GetNumData() << "\" Format=\"ascii\">" << std::endl;
        boost::ptr_vector<CellBase>::const_iterator CellIter = this->mCells.begin();
        while (CellIter != this->mCells.end())
        {
            const VisualizeDataBase* tmpData = CellIter->GetData(CellDataCount);
            if (tmpData->GetDataType() != this->mCellData[CellDataCount].GetDataType())
            {
                throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::ExportVtkDatafile] mismatch in Cell data.");
            }
            file <<"          " << *tmpData << std::endl;
            CellIter++;
        }
        file << "        </DataArray>" << std::endl;
    }

    file << "      </CellData>"<< std::endl;

    // points /////////////////////////////////////////////////////////////////
    // modify format for point coordinate output
    std::ios_base::fmtflags OriginalFlags = file.flags(); // store original format
    file.setf(std::ios_base::uppercase | std::ios_base::scientific | std::ios_base::showpos);

    file << "      <Points>"<< std::endl;
    file << "        <DataArray type=\"Float32\" NumberOfComponents=\"3\" Format=\"ascii\">" << std::endl;
    // write point coordinates to file
    boost::ptr_vector<Point>::const_iterator PointIter = this->mPoints.begin();
    while (PointIter != this->mPoints.end())
    {
        const double* PointCoordinates = PointIter->GetCoordinates();
        file <<"          " << PointCoordinates[0] << " " << PointCoordinates[1] << " " << PointCoordinates[2] << " " << std::endl;
        PointIter++;
    }
    // reset original format
    file.flags(OriginalFlags);
    file << "        </DataArray>"<< std::endl;
    file << "      </Points>"<< std::endl;
    // end points /////////////////////////////////////////////////////////////////////


    // Cells //////////////////////////////////////////////////////////////////
    file << "      <Cells>"<< std::endl;
    file << "        <DataArray type=\"Int32\" Name=\"connectivity\" Format=\"ascii\">" << std::endl;
    boost::ptr_vector<CellBase>::const_iterator CellIter = this->mCells.begin();
    while (CellIter != this->mCells.end())
    {
    	unsigned int NumPoints = CellIter->GetNumPoints();
    	const unsigned int *Points = CellIter->GetPoints();
    	file <<"          ";
        for (unsigned int PointCount = 0; PointCount < NumPoints; PointCount++)
        {
            file << " " << Points[PointCount];
        }
        file << std::endl;
        CellIter++;
    }
    file << "        </DataArray>" << std::endl;
    file << "        <DataArray type=\"Int32\" Name=\"offsets\" Format=\"ascii\">" << std::endl;
    CellIter = this->mCells.begin();
    int offset(0);
    while (CellIter != this->mCells.end())
    {
        offset+=CellIter->GetNumPoints();
        file << " " << offset << std::endl;
        CellIter++;
    }
    file << "        </DataArray>" << std::endl;
    file << "        <DataArray type=\"Int32\" Name=\"types\" Format=\"ascii\">" << std::endl;
    CellIter = this->mCells.begin();
    while (CellIter != this->mCells.end())
    {
        file << CellIter->GetVtkCellType() << std::endl;
        CellIter++;
    }
    file << "        </DataArray>" << std::endl;
    file << "      </Cells>"<< std::endl;
    //end cells /////////////////////////////////////////////////////////////////////////

    // end header /////////////////////////////////////////////////////////////////
    file << "    </Piece>" << std::endl;
    file << "  </UnstructuredGrid>" << std::endl;
    file << "</VTKFile>" << std::endl;

    file.close();
}


// check points
void NuTo::VisualizeUnstructuredGrid::CheckPoints(const unsigned int rNumPoints, const unsigned int *rPoints) const
{
    for (unsigned int PointCount = 0; PointCount < rNumPoints; PointCount++)
    {
        if (rPoints[PointCount] >= this->mPoints.size())
        {
            throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::CheckPoints] Point id is out of range.");
        }
    }
}

// define scalar point data
void NuTo::VisualizeUnstructuredGrid::DefinePointDataScalar(const std::string& rIdent)
{
    this->CheckPointDataIdent(rIdent);
    this->mPointData.push_back(NuTo::VisualizeDataType(rIdent, NuTo::VisualizeDataType::SCALAR));
    unsigned int DataIndex = this->mPointData.size() - 1;
    // add data to all points
    boost::ptr_vector<Point>::iterator PointIter = this->mPoints.begin();
    while (PointIter != this->mPoints.end())
    {
        PointIter->AddDataScalar(DataIndex);
        PointIter++;
    }
}

// define scalar cell data
void NuTo::VisualizeUnstructuredGrid::DefineCellDataScalar(const std::string& rIdent)
{
    this->CheckCellDataIdent(rIdent);
    this->mCellData.push_back(NuTo::VisualizeDataType(rIdent, NuTo::VisualizeDataType::SCALAR));
    unsigned int DataIndex = this->mCellData.size() - 1;
    // add data to all cells
    boost::ptr_vector<CellBase>::iterator CellIter = this->mCells.begin();
    while (CellIter != this->mCells.end())
    {
        CellIter->AddDataScalar(DataIndex);
        CellIter++;
    }
}

// define vector point data
void NuTo::VisualizeUnstructuredGrid::DefinePointDataVector(const std::string& rIdent)
{
    this->CheckPointDataIdent(rIdent);
    this->mPointData.push_back(NuTo::VisualizeDataType(rIdent, NuTo::VisualizeDataType::VECTOR));
    unsigned int DataIndex = this->mPointData.size() - 1;
    // add data to all points
    boost::ptr_vector<Point>::iterator PointIter = this->mPoints.begin();
    while (PointIter != this->mPoints.end())
    {
        PointIter->AddDataVector(DataIndex);
        PointIter++;
    }
}

// define vector cell data
void NuTo::VisualizeUnstructuredGrid::DefineCellDataVector(const std::string& rIdent)
{
    this->CheckCellDataIdent(rIdent);
    this->mCellData.push_back(NuTo::VisualizeDataType(rIdent, NuTo::VisualizeDataType::VECTOR));
    unsigned int DataIndex = this->mCellData.size() - 1;
    // add data to all cells
    boost::ptr_vector<CellBase>::iterator CellIter = this->mCells.begin();
    while (CellIter != this->mCells.end())
    {
        CellIter->AddDataVector(DataIndex);
        CellIter++;
    }
}

// define tensor point data
void NuTo::VisualizeUnstructuredGrid::DefinePointDataTensor(const std::string& rIdent)
{
    this->CheckPointDataIdent(rIdent);
    this->mPointData.push_back(NuTo::VisualizeDataType(rIdent, NuTo::VisualizeDataType::TENSOR));
    unsigned int DataIndex = this->mPointData.size() - 1;
    // add data to all points
    boost::ptr_vector<Point>::iterator PointIter = this->mPoints.begin();
    while (PointIter != this->mPoints.end())
    {
        PointIter->AddDataTensor(DataIndex);
        PointIter++;
    }
}

// define tensor cell data
void NuTo::VisualizeUnstructuredGrid::DefineCellDataTensor(const std::string& rIdent)
{
    this->CheckCellDataIdent(rIdent);
    this->mCellData.push_back(NuTo::VisualizeDataType(rIdent, NuTo::VisualizeDataType::TENSOR));
    unsigned int DataIndex = this->mCellData.size() - 1;
    // add data to all cells
    boost::ptr_vector<CellBase>::iterator CellIter = this->mCells.begin();
    while (CellIter != this->mCells.end())
    {
        CellIter->AddDataTensor(DataIndex);
        CellIter++;
    }
}

// define field point data
void NuTo::VisualizeUnstructuredGrid::DefinePointDataField(const std::string& rIdent, unsigned int rNumData)
{
    this->CheckPointDataIdent(rIdent);
    this->mPointData.push_back(NuTo::VisualizeDataType(rIdent, NuTo::VisualizeDataType::FIELD));
    this->mPointData[this->mPointData.size() - 1].SetNumData(rNumData);
    unsigned int DataIndex = this->mPointData.size() - 1;
    // add data to all points
    boost::ptr_vector<Point>::iterator PointIter = this->mPoints.begin();
    while (PointIter != this->mPoints.end())
    {
        PointIter->AddDataField(DataIndex, rNumData);
        PointIter++;
    }
}

// define field cell data
void NuTo::VisualizeUnstructuredGrid::DefineCellDataField(const std::string& rIdent, unsigned int rNumData)
{
    this->CheckCellDataIdent(rIdent);
    this->mCellData.push_back(NuTo::VisualizeDataType(rIdent, NuTo::VisualizeDataType::FIELD));
    this->mCellData[this->mCellData.size() - 1].SetNumData(rNumData);
    unsigned int DataIndex = this->mCellData.size() - 1;
    // add data to all points
    boost::ptr_vector<CellBase>::iterator CellIter = this->mCells.begin();
    while (CellIter != this->mCells.end())
    {
        CellIter->AddDataField(DataIndex, rNumData);
        CellIter++;
    }
}

// check point data identifier
void NuTo::VisualizeUnstructuredGrid::CheckPointDataIdent(const std::string& rIdent) const
{
    this->CheckDataIdent(rIdent);
    std::vector<VisualizeDataType>::const_iterator iter = mPointData.begin();
    while (iter != mPointData.end())
    {
        if (iter->IsIdent(rIdent))
        {
            break;
        }
        iter++;
    }
    if (iter != mPointData.end())
    {
        throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::CheckPointDataIdent] data identifier already exist for point data.");
    }
}

// check cell data identifier
void NuTo::VisualizeUnstructuredGrid::CheckCellDataIdent(const std::string& rIdent) const
{
    this->CheckDataIdent(rIdent);
    std::vector<VisualizeDataType>::const_iterator iter = mCellData.begin();
    while (iter != mCellData.end())
    {
        if (iter->IsIdent(rIdent))
        {
            break;
        }
        iter++;
    }
    if (iter != mCellData.end())
    {
        throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::CheckCellDataIdent] data identifier already exist for cell data.");
    }
}

// check strings
void NuTo::VisualizeUnstructuredGrid::CheckDataIdent(const std::string& rIdent) const
{
    std::vector<std::string> tokens;
    std::istringstream iss(rIdent);
    std::copy(std::istream_iterator<std::string>(iss), std::istream_iterator<std::string>(), std::back_inserter<std::vector<std::string> >(tokens));
    if (tokens.size() != 1)
    {
        //std::cout << "data ident : " << rIdent << std::endl;
    	throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::CheckDataIdent] data identifier must be a single word.");
    }
}

// set scalar point data
void NuTo::VisualizeUnstructuredGrid::SetPointDataScalar(unsigned int rPointIndex, const std::string& rDataIdent, double rData)
{
    if (rPointIndex >= this->mPoints.size())
    {
        throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::SetPointDataScalar] invalid point index.");
    }
    unsigned int PointDataIndex = this->GetPointDataIndex(rDataIdent);
    this->mPoints[rPointIndex].SetDataScalar(PointDataIndex, rData);
}

// set vector point data
void NuTo::VisualizeUnstructuredGrid::SetPointDataVector(unsigned int rPointIndex, const std::string& rDataIdent, double rData[3])
{
    if (rPointIndex >= this->mPoints.size())
    {
        throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::SetPointDataVector] invalid point index.");
    }
    unsigned int PointDataIndex = this->GetPointDataIndex(rDataIdent);
    this->mPoints[rPointIndex].SetDataVector(PointDataIndex, rData);
}

// set scalar cell data
void NuTo::VisualizeUnstructuredGrid::SetCellDataScalar(unsigned int rCellIndex, const std::string& rDataIdent, double rData)
{
    if (rCellIndex >= this->mCells.size())
    {
        throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::SetCellDataScalar] invalid cell index.");
    }
    unsigned int CellDataIndex = this->GetCellDataIndex(rDataIdent);
    this->mCells[rCellIndex].SetDataScalar(CellDataIndex, rData);
}

// set vector cell data
void NuTo::VisualizeUnstructuredGrid::SetCellDataVector(unsigned int rCellIndex, const std::string& rDataIdent, double rData[3])
{
    if (rCellIndex >= this->mCells.size())
    {
        throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::SetCellDataTensor] invalid cell index.");
    }
    unsigned int CellDataIndex = this->GetCellDataIndex(rDataIdent);
    this->mCells[rCellIndex].SetDataVector(CellDataIndex, rData);
}

// set tensor cell data
void NuTo::VisualizeUnstructuredGrid::SetCellDataTensor(unsigned int rCellIndex, const std::string& rDataIdent, double rData[9])
{
    if (rCellIndex >= this->mCells.size())
    {
        throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::SetCellDataTensor] invalid cell index.");
    }
    unsigned int CellDataIndex = this->GetCellDataIndex(rDataIdent);
    this->mCells[rCellIndex].SetDataTensor(CellDataIndex, rData);
}

// get point data index
unsigned int NuTo::VisualizeUnstructuredGrid::GetPointDataIndex(const std::string& rIdent) const
{
    for (unsigned int PointDataCount = 0; PointDataCount < this->mPointData.size(); PointDataCount++)
    {
        if (this->mPointData[PointDataCount].IsIdent(rIdent))
        {
            return PointDataCount;
        }
    }
    throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::GetPointDataIndex] data identifier not found.");
}

// get cell data index
unsigned int NuTo::VisualizeUnstructuredGrid::GetCellDataIndex(const std::string& rIdent) const
{
    for (unsigned int CellDataCount = 0; CellDataCount < this->mCellData.size(); CellDataCount++)
    {
        if (this->mCellData[CellDataCount].IsIdent(rIdent))
        {
            return CellDataCount;
        }
    }
    std::cout << rIdent << std::endl;
    throw NuTo::VisualizeException("[NuTo::VisualizeUnstructuredGrid::GetCellDataIndex] data identifier not found.");
}
